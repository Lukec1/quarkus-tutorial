= Fault Tolerance

[.console-input]
[source,bash]
----
./mvnw quarkus:add-extension -Dextension=quarkus-smallrye-fault-tolerance
----

[.console-output]
[source,text]
----
[INFO] Scanning for projects...
[INFO]
[INFO] -----------------< com.redhat.developers:tutorial-app >-----------------
[INFO] Building tutorial-app 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- quarkus-maven-plugin:1.4.2.Final:add-extension (default-cli) @ tutorial-app ---
âœ… Adding extension io.quarkus:quarkus-smallrye-fault-tolerance
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.963 s
[INFO] Finished at: 2020-05-11T22:39:44-04:00
[INFO] ------------------------------------------------------------------------
----

[#qext-retry-fruity-vice-service]
== Add Retry to Fruity Vice Service

Let's add the retry policy in `FruityViceService`.

Add the `org.eclipse.microprofile.faulttolerance.Retry` annotation to `pass:[$PROJECT_HOME]/src/main/java/java/com/example/FruityViceService.java`:

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.eclipse.microprofile.faulttolerance.Retry;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/api/fruit")
@RegisterRestClient
public interface FruityViceService {

    @GET
    @Path("/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Retry(maxRetries = 3, delay = 2000)
    public FruityVice getFruitByName(@PathParam("name") String name);
    
}
----

Now in case of any error, 3 retries are done automatically, waiting for 2 seconds between retries.

[#qext-fault-tolerance-run-quarkus-app-dev-mode]
== Run Quarkus Application in Development mode

:section-build-run: fault-tolerance

include::ROOT:partial$run-dev-mode.adoc[]

[#qext-call-fruity-fault-tolerance-retry]
=== Invoke Service
:doc-sec: fault-tolerance-retry
:k8s-cli: cli
:path: fruit/banana
:k8s-env: minikube
:cli-tool: curl
:address: localhost

The simple `{path}` REST URI can be called via browser using http://localhost:8080/{path} or using CLI like: 

include::ROOT:partial$invoke-service.adoc[tag=call]

The REST call should return an response like:

[.console-output]
[source,json]
----
{
    "name":"Banana",
    "nutritions":{
        "calories":96,
        "fat":0.2
    }
}
----

No change from calls done previously, but now switch off your network so you do not have access to http://www.fruityvice.com.
And make again a request to http://localhost:8080/{path}.

:doc-sec: fault-tolerance-retry-no-network
include::ROOT:partial$invoke-service.adoc[tag=call]

Now after waiting 6 seconds (3 retries x 2 seconds), the next exception is thrown `java.net.UnknownHostException: www.fruityvice.com`.

[#qext-fallback-fruity-vice-service]
== Add Fallback to Fruity Vice Service

Let's add a fallback policy in case of an error in `FruityViceService`.

Add the `org.eclipse.microprofile.faulttolerance.Fallback` annotation to `pass:[$PROJECT_HOME]/src/main/java/java/com/example/FruityViceService.java`:

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import com.redhat.developers.FruityVice.Nutritions;

import org.eclipse.microprofile.faulttolerance.ExecutionContext;
import org.eclipse.microprofile.faulttolerance.Fallback;
import org.eclipse.microprofile.faulttolerance.FallbackHandler;
import org.eclipse.microprofile.faulttolerance.Retry;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/api/fruit")
@RegisterRestClient
public interface FruityViceService {

    @GET
    @Path("/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Retry(maxRetries = 3, delay = 2000)
    @Fallback(FruityViceFallback.class)
    public FruityVice getFruitByName(@PathParam("name") String name);
    
    public static class FruityViceFallback implements FallbackHandler<FruityVice> {

        private static final FruityVice EMPTY_FRUITY_VICE = FruityVice.of("empty", Nutritions.of(0.0, 0.0));
        @Override
        public FruityVice handle(ExecutionContext context) {
            return EMPTY_FRUITY_VICE;
        }
 
    }

}
----

Now in case of any error, 3 retries are done automatically, waiting for 2 seconds between retries. 
If the error persits, then the fallback method is executed.

[#qext-fault-tolerance-fallback-run-quarkus-app-dev-mode]
== Run Quarkus Application in Development mode

:section-build-run: fault-tolerance-fallback

include::ROOT:partial$run-dev-mode.adoc[]

[#qext-call-fruity-fault-tolerance-fallback]
=== Invoke Service
:doc-sec: fault-tolerance-fallback
:k8s-cli: k8s
:path: fruit/banana
:k8s-env: minikube
:cli-tool: curl
:address: localhost

The simple `{path}` REST URI can be called via browser using http://localhost:8080/{path} or using CLI like: 

include::ROOT:partial$invoke-service.adoc[tag=call]

Now after waiting for 6 seconds (3 retries x 2 seconds), an empty object is sent instead of an exception.

[source,json]
----
{}
----

[#qext-circuit-breaker-fruity-vice-service]
== Add Circuit Breaker to Fruity Vice Service

Let's add the circuit breaker policy in `FruityViceService`.

Remove previous annotations of fallback and retry policies and add the following annotation to `pass:[$PROJECT_HOME]/src/main/java/java/com/example/FruityViceService.java`:

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.eclipse.microprofile.faulttolerance.CircuitBreaker;
import org.eclipse.microprofile.faulttolerance.Retry;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/api/fruit")
@RegisterRestClient
public interface FruityViceService {

    @GET
    @Path("/{name}")
    @Produces(MediaType.APPLICATION_JSON)
    @Retry(maxRetries = 3, delay = 2000)
    @CircuitBreaker(requestVolumeThreshold = 4, failureRatio = 0.75, delay = 5000)
    public FruityVice getFruitByName(@PathParam("name") String name);
    
}
----

Now, if 3 (4 x 0.75) failures occur among the rolling window of 4 consecutive invocations then the circuit is opened for 5000 ms and then be back to half open. 
If the invocation succeeds then the circuit is back to closed again.

[#qext-circuit-breaker-run-quarkus-app-dev-mode]
== Run Quarkus Application in Development mode

:section-build-run: fault-tolerance-circuit-breaker

include::ROOT:partial$run-dev-mode.adoc[]

[#qext-call-fruity-fault-tolerance-circuit-breaker]
=== Invoke Service
:doc-sec: fault-tolerance-cb
:k8s-cli: k8s
:path: fruit/banana
:k8s-env: minikube
:cli-tool: curl
:address: localhost

Do 5 consecutive calls to the service, `{path}` REST URI can be called via browser using http://localhost:8080/{path} or using CLI like: 

include::ROOT:partial$invoke-service.adoc[tag=call]

The output changes form `java.net.UnknownHostException: www.fruityvice.com` (or any other network exception) in the first calls to `org.eclipse.microprofile.faulttolerance.exceptions.CircuitBreakerOpenException: getFruitByName` when circuit is opened.

The big difference between first exception and second one is that in first one, occurs because the circuit is closed and means that the system is trying to reach the host, in the second one, the circuit is closed and the exception is thrown automatically instead of trying to reach the host.

TIP: You can use `@Retry` and `@Fallback` annotations together with `@CircuitBreaker` annotation.

[#qext-turn-on-network]
== Turn Network on

Turn network on again to continue with the workshop.

[#qext-health-checks]
== Health checks

If you had observed, the quarkus application deployed on Kubernetes does not have any health checks on it. As Kubernetes best practice its highly recommended that health checks be added to the all the deployments.

Health checks in Kubernetes can be added using https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/[Liveness and Readiness] probes.