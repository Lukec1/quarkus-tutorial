= Reactive Programming

[.console-input]
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions=io.quarkus:quarkus-resteasy-mutiny
----

[.console-output]
[source,text]
----
[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------< com.redhat.developers:tutorial-app >-----------------
[INFO] Building tutorial-app 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- quarkus-maven-plugin:1.4.2.Final:add-extension (default-cli) @ tutorial-app ---
✅ Adding dependency io.quarkus:quarkus-resteasy-mutiny:jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.217 s
[INFO] Finished at: 2020-05-12T09:03:59-04:00
[INFO] ------------------------------------------------------------------------
----

include::_attributes.adoc[]
:quarkus-project-name: fruits-app
:svc-path: beer

At the end of this chapter you will be able to :

* [x] Use reactive programming in Quarkus.
* [x] How to use Reactive programming for accessing Rest API services with pagination and back pressure.

[#quarkusrpb-demo-overview]
== Beer Demo Overview 

To demonstrate how to use reactive programming in Quarkus, you will be developing a REST client that connects to a beer database (https://punkapi.com/documentation/v2) to retrieve beer information.
This API does not return all beers at once, but you need to use pagination to navigate through all beer database.

In this section, you are going to develop a service that returns all beers with an _abv_ value greater than _7.0_ and using a reactive approach as a solution.

[#quarkusrpb-buld-beer-reactive]
=== Build Beer Service

The skeleton project to get started is the same you created at xref:02-basics-fundas.adoc[Basics and Fundamentals].

NOTE: For the easier reference, we shall call the `fruits-app` project folder as pass:[$PROJECT_HOME]

[#quarkusrpb-create-pojo]
==== Create Beer POJO

Let's create the `Beer` pojo.

Add new Java file in `$PROJECT_HOME/src/main/java/com/example` called `Beer` with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.json.bind.annotation.JsonbCreator;

public class Beer {

    private String name;

    private String tagline;

    private double abv;

	private Beer(String name, String tagline, double abv) {
		this.name = name;
		this.tagline = tagline;
		this.abv = abv;
	}

    @JsonbCreator
    public static Beer of(String name, String tagline, double abv) {
        return new Beer(name, tagline, abv);
     }

     public String getName() {
         return name;
     }

     public String getTagline() {
         return tagline;
     }

     public double getAbv() {
         return abv;
     }

}
----

[#quarkusrpb-create-beer-client]
==== Create Rest Client to Punk Beer API

Add new Java file in `$PROJECT_HOME/src/main/java/com/example` called `BeerGateway` with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import java.util.List;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@Path("/v2")
@RegisterRestClient
public interface BeerService {
    
    @GET
    @Path("/beers")
    @Produces(MediaType.APPLICATION_JSON)
    List<Beer> getBeers(@QueryParam("page") int page);

}
----

=== Edit the application.properties

Add the following properties to pass:[$PROJECT_HOME]/src/main/resources/application.properties:

[.console-input]
[source,properties]
----
com.redhat.developers.BeerService/mp-rest/url=https://api.punkapi.com
----

[#quarkusrpb-beer-reactive-service]
=== Create Beer Punk API Reactive Service

Let's create the service that uses `BeerGateway` to retrieve beer information by page and reactively emits each of the beer information.

Add new Java file in `$PROJECT_HOME/src/main/java/com/example` called `BeerService` with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.eclipse.microprofile.rest.client.inject.RestClient;

import io.smallrye.mutiny.Multi;

@Path("/beer")
public class BeerResource {
    
    @Inject
    @RestClient
    BeerService beerService;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Multi<Beer> beers() {
        return Multi.createBy().repeating() //1
            .supplier(
                () -> new AtomicInteger(1), //2
                i -> beerService.getBeers(i.getAndIncrement()) //3
            )
            .until(List::isEmpty) //4
            .onItem().<Beer>disjoint() //5
            .transform().byFilteringItemsWith(b -> b.getAbv() > 15.0); //6
    }

}
----

. Gets first batch of beers
. Sends an event that the process is completed
. Emits each beer
. Gets beers from next page
. Flatten the list of beers event into event of beers

So far nothing really new, but notice that now instead of reading all the beers, put them in memory and then filter out by any parameter, you are just emitting them individually per page.
The caller is responsible to manipulate this information as it starts receiving the information and it is not necessary to store all beers in memory but just the ones that matches any condition.

Notice that until a caller subscribes to a stream (`Flowable` in this case), the logic is not executed.

[.console-output]
[source,json]
----
[
  {
    "abv": 55,
    "name": "The End Of History",
    "tagline": "The World's Strongest Beer."
  },
  {
    "abv": 16.5,
    "name": "Anarchist Alchemist",
    "tagline": "Triple Hopped Triple Ipa."
  },
  {
    "abv": 15.2,
    "name": "Lumberjack Stout",
    "tagline": "Blueberry Bacon Stout."
  },
  {
    "abv": 18.3,
    "name": "Bowman's Beard - B-Sides",
    "tagline": "English Barley Wine."
  },
  {
    "abv": 41,
    "name": "Sink The Bismarck!",
    "tagline": "IPA For The Dedicated."
  },
  {
    "abv": 16.2,
    "name": "Tokyo*",
    "tagline": "Intergalactic Stout. Rich. Smoky. Fruity."
  },
  {
    "abv": 18,
    "name": "AB:02",
    "tagline": "Triple Dry Hopped Imperial Red Ale."
  },
  {
    "abv": 17.2,
    "name": "Black Tokyo Horizon (w/Nøgne Ø & Mikkeller)",
    "tagline": "Imperial Stout Collaboration."
  },
  {
    "abv": 16.1,
    "name": "Dog D",
    "tagline": "Anniversary Imperial Stout."
  },
  {
    "abv": 32,
    "name": "Tactical Nuclear Penguin",
    "tagline": "Uber Imperial Stout."
  },
  {
    "abv": 16.1,
    "name": "Dog E",
    "tagline": "Ninth Anniversary Imperial Stout."
  },
  {
    "abv": 17,
    "name": "Dog G",
    "tagline": "11th Anniversary Imperial Stout."
  }
]
----
