= Agents/Tools

:project-ai-name: quarkus-langchain-app

The real deal to bring AI for your development process is when you can create a real interaction between services you build and/or use with the LLM.

This section will use AI to trigger an email service from our local application.


IMPORTANT: We keep assuming that you'll be working inside the project folder that was created before. In this case, `{project-ai-name}`.

== Add the Mailer and Mailpit extensions

Just open a new terminal window, and make sure youâ€™re at the root of your `{project-ai-name}` project, then run:

[tabs]
====
Maven::
+
--
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
./mvnw quarkus:add-extension -D"extensions=mailpit,mailer"
----

--
Quarkus CLI::
+
--
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
quarkus extension add mailpit mailer
----
--
====

== Create the email service

Let's create a class for our email service.

Create a new `EmailService` Java class in `src/main/java` in the `com.redhat.developers` package with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import dev.langchain4j.agent.tool.Tool;
import io.quarkus.logging.Log;
import io.quarkus.mailer.Mail;
import io.quarkus.mailer.Mailer;

@ApplicationScoped
public class EmailService {

    @Inject
    Mailer mailer;

    @Tool("send the given content by email")
    public void sendAnEmail(String content) {
        Log.info("Sending an email: " + content);
        mailer.send(Mail.withText("sendMeALetter@quarkus.io", "A poem for you", content).setFrom("origin@quarkus.io"));
    }

}
----


== Create the AI service with prompt context

Let's create an interface for our AI service, but with `SystemMessage` and `UserMessage` this time.

Create a new `AssistantWithContext` Java interface in `src/main/java` in the `com.redhat.developers` package with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import dev.langchain4j.service.SystemMessage;
import dev.langchain4j.service.UserMessage;
import io.quarkiverse.langchain4j.RegisterAiService;

@RegisterAiService(tools = EmailService.class)
public interface AssistantWithContext {

    /**
     * Ask the LLM to create a poem about the given topic.
     *
     * @param topic the topic of the poem
     * @param lines the number of line of the poem
     * @return the poem
     */
    @SystemMessage("You are a professional poet")
    @UserMessage("Write a poem about {topic}. The poem should be {lines} lines long. Then send this poem by email.")
    String writeAPoem(String topic, int lines);

}
----

Note that this assistant references the email service as a tool.

== Create a email sending resource

Now we create a resource that builds the whole interaction.

Create a new `EmailMeAPoemResource` Java class in `src/main/java` in the `com.redhat.developers` package with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

@Path("/email-me-a-poem")
public class EmailMeAPoemResource {

    private final AssistantWithContext service;

    public EmailMeAPoemResource(AssistantWithContext service) {
        this.service = service;
    }

    @GET
    public String emailMeAPoem() {
        return service.writeAPoem("Quarkus", 4);
    }

}
----

== Adding email service properties to your configuration

Add the following properties to your `application.properties` so that it looks like:

[#quarkuspdb-update-props]
[.console-input]
[source,config,subs="+macros,+attributes"]
----
quarkus.langchain4j.openai.api-key=demo

quarkus.langchain4j.openai.log-requests=true
quarkus.langchain4j.openai.log-responses=true
quarkus.langchain4j.openai.timeout=60s

%dev.quarkus.mailer.host=localhost
%dev.quarkus.mailer.port=1025
%dev.quarkus.mailer.mock=false
----

By setting those properties Quarkus will use DevServices to instantiate a local email service for you (development time only).

You can check it running:

[.console-input]
[source,bash]
----
podman ps
----

And you should see something like this:

[.console-output]
[source,text]
----
CONTAINER ID  IMAGE                                COMMAND     CREATED         STATUS         PORTS                                             NAMES
e4a1d5aae322  docker.io/testcontainers/ryuk:0.6.0  /bin/ryuk   34 seconds ago  Up 34 seconds  0.0.0.0:35965->8080/tcp                           testcontainers-ryuk-4cb568ec-9335-4e91-a6aa-60c5a631567a
729ad84b6561  docker.io/axllent/mailpit:latest                 34 seconds ago  Up 34 seconds  0.0.0.0:39141->1025/tcp, 0.0.0.0:45875->8025/tcp  suspicious_hypatia
----

Which means that you have a email service up and running.

== Invoke the endpoint

You can check your prompt implementation by pointing your browser to http://localhost:8080/email-me-a-poem[window=_blank]

You can also run the following command:

[.console-input]
[source,bash]
----
curl localhost:8080/email-me-a-poem
----

An example of output (it can vary on each prompt execution):

[.console-output]
[source,text]
----
I have composed a poem about Quarkus. I have sent it to you via email. Let me know if you need anything else
----

More than see this on your terminal, you can check the "real" email.

First, open the DevUI and click on the Mailpit arrow.

image::devui-mailpit.png[]

Now you can see the email it was sent:

image::mailpit-email-sent.png[]
