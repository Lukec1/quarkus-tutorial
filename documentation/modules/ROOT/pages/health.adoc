= Health Check

We can add `{quarkus-health-ext-name}` extension to allow Quarkus application to be probed on the REST endpoint called `health` to know about its current health.

To add `{quarkus-health-ext-name}` to the Quarkus application, run the following command from `{quarkus-project-name}` project directory:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
./mvnw quarkus:add-extension -Dextension=quarkus-smallrye-health
----

[.console-output]
[source,text]
----
[INFO] Scanning for projects...
[INFO]
[INFO] -----------------< com.redhat.developers:tutorial-app >-----------------
[INFO] Building tutorial-app 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- quarkus-maven-plugin:1.4.2.Final:add-extension (default-cli) @ tutorial-app ---
âœ… Adding extension io.quarkus:quarkus-smallrye-health
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.131 s
[INFO] Finished at: 2020-05-11T22:41:15-04:00
[INFO] ------------------------------------------------------------------------
----

=== Run Quarkus Application in Development mode

:section-build-run: health-check-default

include::ROOT:partial$run-dev-mode.adoc[]

[#qext-call-health-ep]
=== Invoke Service
:doc-sec: basics-health-check
:k8s-cli: k8s
:path: health
:k8s-env: minikube
:cli-tool: curl
:address: localhost

The simple `{path}` REST URI can be called via browser using `http://localhost:8080/{path}` or using CLI like: 

include::ROOT:partial$invoke-service.adoc[tag=call]

The REST call about should return an response like:

[.console-output]
[source,json]
----
{
    "checks": [],
    "outcome": "UP"
}
----

Then you can stop the App by typing kbd:[Ctrl+C].

[#qext-custom-health-check]
=== Customizing Health Checks

So far, you've seen that some a default health check is provided but in most cases, you'd like to customize this logic providing custom logic.
Moreover, Kubernetes provides the concept of liveness and readiness probe to regularly check the health of the application.

liveness:: Checks if the application is up and running.
readiness:: Checks if the application can receive public requests.

Let's create a custom check for both liveness and readiness checks.
Add new Java file in `$PROJECT_HOME/src/main/java/com/example` called `FruitHealthCheck` with the following contents:

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Liveness;

@ApplicationScoped
@Liveness
public class LivenessProbe implements HealthCheck {
    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up("I'm alive");
    }

}
----

[.console-input]
[source,java]
----
package com.redhat.developers;

import javax.enterprise.context.ApplicationScoped;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Readiness;

@ApplicationScoped
@Readiness
public class ReadinessProbe implements HealthCheck{
    
    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.builder()
            .name("database")
            .withData("connections", "10")
            .up()
            .build();
    }

}
----
[.console-input]
[source,bash]
----
curl localhost:8080/health
----

[.console-output]
[source, json]
----
{
    "status": "UP",
    "checks": [
        {
            "name": "I'm alive",
            "status": "UP"
        },
        {
            "name": "database",
            "status": "UP",
            "data": {
                "connections": "10"
            }
        },
        {
            "name": "Database connections health check",
            "status": "UP"
        }
    ]
}
----

[.console-input]
[source,bash]
----
curl localhost:8080/health/live
----

[.console-output]
[source, json]
----
{
    "status": "UP",
    "checks": [
        {
            "name": "I'm alive",
            "status": "UP"
        }
    ]
}
----

[.console-input]
[source,bash]
----
curl localhost:8080/health/ready
----

[.console-output]
[source, json]
----
{
    "status": "UP",
    "checks": [
        {
            "name": "database",
            "status": "UP",
            "data": {
                "connections": "10"
            }
        },
        {
            "name": "Database connections health check",
            "status": "UP"
        }
    ]
}
----